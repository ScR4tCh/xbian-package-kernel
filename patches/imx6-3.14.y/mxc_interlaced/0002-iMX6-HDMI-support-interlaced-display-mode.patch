From ef93be8739e12330b998e8453f6e87dc23e0397a Mon Sep 17 00:00:00 2001
From: Li Qiang <b19715@freescale.com>
Date: Thu, 24 Apr 2014 09:54:38 +0800
Subject: [PATCH 2/3] iMX6 HDMI support interlaced display mode.

---
 drivers/video/mxc/mxc_edid.c | 18 ++++++++++++++----
 drivers/video/mxc_hdmi.c     | 31 ++++++++++++++++++++++---------
 3 files changed, 48 insertions(+), 23 deletions(-)

diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
index 721ff88..baf597a 100644
--- a/drivers/video/mxc/mxc_edid.c
+++ b/drivers/video/mxc/mxc_edid.c
@@ -62,18 +62,18 @@ const struct fb_videomode mxc_cea_mode[64] = {
 	},
 	/* #5: 1920x1080i@59.94/60Hz 16:9 */
 	[5] = {
-		NULL, 60, 1920, 1080, 13763, 148, 88, 15, 2, 44, 5,
+		NULL, 60, 1920, 1080, 13468, 88, 148, 4, 31, 44, 10,
 		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
 	/* #6: 720(1440)x480iH@59.94/60Hz 4:3 */
 	[6] = {
-		NULL, 60, 1440, 480, 18554/*37108*/, 114, 38, 15, 4, 124, 3, 0,
+		NULL, 60, 1440, 480, 37037, 38, 114, 8, 31, 124, 6, 0,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_4_3, 0,
 	},
 	/* #7: 720(1440)x480iH@59.94/60Hz 16:9 */
 	[7] = {
-		NULL, 60, 1440, 480, 18554/*37108*/, 114, 38, 15, 4, 124, 3, 0,
+		NULL, 60, 1440, 480, 37037, 38, 114, 8, 31, 124, 6, 0,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
 	/* #8: 720(1440)x240pH@59.94/60Hz 4:3 */
@@ -120,10 +120,20 @@ const struct fb_videomode mxc_cea_mode[64] = {
 	},
 	/* #20: 1920x1080i@50Hz */
 	[20] = {
-		NULL, 50, 1920, 1080, 13480, 148, 528, 15, 5, 528, 5,
+		NULL, 50, 1920, 1080, 13468, 528, 148, 4, 31, 44, 10,
 		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
+	/* #21: 720(1440)x576i@50Hz */
+	[21] = {
+		NULL, 50, 1440, 576, 37037, 24, 138, 4, 39, 126, 6, 0,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #22: 720(1440)x576i@50Hz */
+	[22] = {
+		NULL, 50, 1440, 576, 37037, 24, 138, 4, 39, 126, 6, 0,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
 	/* #23: 720(1440)x288pH@50Hz 4:3 */
 	[23] = {
 		NULL, 50, 1440, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
@@ -750,17 +750,19 @@ const struct fb_videomode *mxc_fb_find_nearest_mode(const struct fb_videomode *mode,
 		   ((mode->vmode & FB_VMODE_3D_MASK) != (cmode->vmode & FB_VMODE_3D_MASK)))
 			continue;
 
-		d = abs(cmode->xres - mode->xres) +
-			abs(cmode->yres - mode->yres);
-		if (diff > d) {
-			diff = d;
-			diff_refresh = abs(cmode->refresh - mode->refresh);
-			best = cmode;
-		} else if (diff == d) {
-			d = abs(cmode->refresh - mode->refresh);
-			if (diff_refresh > d) {
-				diff_refresh = d;
+		if ((cmode->vmode & FB_VMODE_INTERLACED) == (mode->vmode & FB_VMODE_INTERLACED)) {
+			d = abs(cmode->xres - mode->xres) +
+				abs(cmode->yres - mode->yres);
+			if (diff > d) {
+				diff = d;
+				diff_refresh = abs(cmode->refresh - mode->refresh);
 				best = cmode;
+			} else if (diff == d) {
+				d = abs(cmode->refresh - mode->refresh);
+				if (diff_refresh > d) {
+					diff_refresh = d;
+					best = cmode;
+				}
 			}
 		}
 	}
diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index c5069aa..7902b3a 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -1464,8 +1464,13 @@ static void hdmi_av_composer(struct mxc_hdmi *hdmi)
 	hdmi_writeb(fb_mode.xres, HDMI_FC_INHACTV0);
 
 	/* Set up vertical blanking pixel region width */
-	hdmi_writeb(fb_mode.yres >> 8, HDMI_FC_INVACTV1);
-	hdmi_writeb(fb_mode.yres, HDMI_FC_INVACTV0);
+	if (vmode->mInterlaced) {
+		hdmi_writeb((fb_mode.yres/2) >> 8, HDMI_FC_INVACTV1);
+		hdmi_writeb((fb_mode.yres/2), HDMI_FC_INVACTV0);
+	} else {
+		hdmi_writeb(fb_mode.yres >> 8, HDMI_FC_INVACTV1);
+		hdmi_writeb(fb_mode.yres, HDMI_FC_INVACTV0);
+	}
 
 	/* Set up horizontal blanking pixel region width */
 	hblank = fb_mode.left_margin + fb_mode.right_margin +
@@ -1476,21 +1481,30 @@ static void hdmi_av_composer(struct mxc_hdmi *hdmi)
 	/* Set up vertical blanking pixel region width */
 	vblank = fb_mode.upper_margin + fb_mode.lower_margin +
 		fb_mode.vsync_len;
-	hdmi_writeb(vblank, HDMI_FC_INVBLANK);
+	if (vmode->mInterlaced)
+		hdmi_writeb(vblank/2, HDMI_FC_INVBLANK);
+	else
+		hdmi_writeb(vblank, HDMI_FC_INVBLANK);
 
 	/* Set up HSYNC active edge delay width (in pixel clks) */
 	hdmi_writeb(fb_mode.right_margin >> 8, HDMI_FC_HSYNCINDELAY1);
 	hdmi_writeb(fb_mode.right_margin, HDMI_FC_HSYNCINDELAY0);
 
 	/* Set up VSYNC active edge delay (in pixel clks) */
-	hdmi_writeb(fb_mode.lower_margin, HDMI_FC_VSYNCINDELAY);
+	if (vmode->mInterlaced)
+		hdmi_writeb(fb_mode.lower_margin / 2, HDMI_FC_VSYNCINDELAY);
+	else
+		hdmi_writeb(fb_mode.lower_margin, HDMI_FC_VSYNCINDELAY);
 
 	/* Set up HSYNC active pulse width (in pixel clks) */
 	hdmi_writeb(fb_mode.hsync_len >> 8, HDMI_FC_HSYNCINWIDTH1);
 	hdmi_writeb(fb_mode.hsync_len, HDMI_FC_HSYNCINWIDTH0);
 
 	/* Set up VSYNC active edge delay (in pixel clks) */
-	hdmi_writeb(fb_mode.vsync_len, HDMI_FC_VSYNCINWIDTH);
+	if (vmode->mInterlaced)
+		hdmi_writeb(fb_mode.vsync_len / 2, HDMI_FC_VSYNCINWIDTH);
+	else
+		hdmi_writeb(fb_mode.vsync_len, HDMI_FC_VSYNCINWIDTH);
 
 	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
 }
@@ -1962,9 +1962,8 @@
 		if ((vic = mxc_edid_mode_to_vic(mode, 0)))
 			nvic++;
 
-		if ((mode->vmode & FB_VMODE_INTERLACED) ||
-			(hdmi->edid_cfg.hdmi_cap && 
-			(vic == 0)))
+		if (hdmi->edid_cfg.hdmi_cap && 
+			(vic == 0))
 				continue;
 
 		if (!(mode->vmode & FB_VMODE_ASPECT_MASK)) {
@@ -1853,7 +1866,7 @@ static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
 	/*Add all no interlaced CEA mode to default modelist */
 	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
 		mode = &mxc_cea_mode[i];
-		if (!(mode->vmode & FB_VMODE_INTERLACED) && (mode->xres != 0))
+		if (mode->xres != 0)
 			fb_add_videomode(mode, &hdmi->fbi->modelist);
 	}
 
@@ -2492,7 +2505,7 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 	/*Add all no interlaced CEA mode to default modelist */
 	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
 		mode = &mxc_cea_mode[i];
-		if (!(mode->vmode & FB_VMODE_INTERLACED) && (mode->xres != 0))
+		if (mode->xres != 0)
 			fb_add_videomode(mode, &hdmi->fbi->modelist);
 	}
 
-- 
1.8.0
